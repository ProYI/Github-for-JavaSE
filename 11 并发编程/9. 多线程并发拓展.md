## 多线程并发拓展  
### 死锁  
- 死锁 - 必要条件  
  1. 互斥条件
  2. 请求和保持条件
  3. 不剥夺条件
  4. 环路等待条件  
### 多线程并发最佳实践
- 使用本地变量  
- 使用不可变类
- 最小化锁的作用域范围: S=1/(1-a+a/n)  
  a是并行计算所占的比例 
  n是并行处理的节点个数  
  s表示最小加速比  
  当`1-a=0`时，没有串行，只有并行，s是等于n的  
  当`a=0`时，只有串行，没有并行，最小加速比s等于1  
  当n趋向于无穷大时，s趋向于 `1/1-a`，这也是加速比的上限  
  `阿姆达尔定律`
- 使用线程池的Executor，而不是直接`new Thread`执行  
- 宁可使用`同步`，也不要使用线程的wait和notify  
- 使用`BlockingQueue`实现生产-消费模式  
- 使用`并发集合`而不是加了锁的同步集合  
- 使用`Semaphore`创建有界的访问  
- 宁可使用`同步代码块`，也不使用同步的方法  
- 避免使用静态变量  
### Spring与线程安全  
- Spring bean:singleton、 prototype  
  Spring对每个Bean提供了scope（作用域），它是这个Bean的生命周期  
  比如scope为singleton（单例），在第一次注入时会创建一个单例对象，该对象会一直复用到应用结束，singleton是容器默认的scope，生命周期与Spring IOC容器是一致的  
  scope为prototype时，每次注入都会创建一个新的对象
- 无状态对象  
  每个无状态的单例对象都是线程安全的  
  自身没有状态，自然不会因为多个线程交替调度，破坏自身状态导致线程安全问题  
  无状态对象包括DTO、VO这些只作为数据实体对象，还有Service、Dao、Controller  

Spring根本就没有对Bean的多线程安全问题做出任何的保证与措施，对于每个Bean的线程安全问题根本原因是因为每个Bean自身的设计：`没有在Bean中声明任何有状态的实例变量或类变量`  
如果必须在Spring管理中加入有状态的实例或类变量，让类变成一个有状态的对象时，那么就需要使用ThreadLocal把变量变成线程私有的  
如果Bean的实例变量或类变量需要在多个线程间共享，就只能使用`syncsynchronized`、`Lock`、`CAS`等实现线程同步的方法  