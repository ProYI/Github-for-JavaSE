## 线程安全性  
- 当多个线程访问某个类时，不管运行时环境采用`何种调度方式`或者这些进程将如何交替执行，并且在主调代码中`不需要任何额外的同步或协同`，这个类都能表现出`正确的行为`，那么就称这个类是线程安全的  

表现方面：  
- 原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作  
- 可见性：一个线程对主内存的修改可以及时的被其他线程观察到  
- 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序  

### 原子性 - Atomic包  
- AtomicXXX：CAS、Unsafe.compareAndSwapInt  
  ```java
  count.incrementAndGet();
  ```
  ```java
    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }
  ```
  ```java
    // var2 传进来的原生值 var4 增加的值 比如 count++时 原count为 （2 + 1）的计算
    public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        do {
            // 从Java底层获取的 var2的值 是否相等，被其他线程修改
            var5 = this.getIntVolatile(var1, var2);
            // var1 count对象 当 传进来var2与底层 var5值相同，count对象更新成 var5 + var4
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

        return var5;
    }
  ```
- AtomicLong、LongAdder  
  CAS的底层实现是在一个死循环中不断尝试修改目标值，直到修改成功。  
  如果竞争不激烈时，修改成功概率很高，反之，修改失败的概率很高，在大量失败的情况下会进行多次的循环尝试，性能会受到一定影响  
  对于普通类型的long、double变量，JVM允许将64位的读/写操作，拆分成两个32位的操作

  LongAdder的实现思想：  
  它将热点数据分离，比如将AtomicLong的内部核心数据`value`分离成一个数组，每个线程访问时通过hash等算法，映射到其中的一个数字进行计数，而最终结果是这个数组的求和累加  
  其中热点数据value会被分离成多个单元的`Cell`，每个Cell独立维护内部的值，当前对象的值由所有的cell累计合成，这样热点就进行了有效的分离，并提高了并行度  
  LongAdder在AtomicLong的基础上，将单点的更新压力分散到各个节点上，在低并发的时候，通过对`base`的直接更新，可以很好地保障和Atomic的性能基本一致；在高并发时则通过分散提高了性能  

  LongAdder的缺点：    
  在统计时如果有并发更新，可能会导致统计数据有误差  
  实际使用中，在高并发情况下可以优先使用LongAdder  
  在线程竞争很低的情况下，使用Atomic更简单，直接，并且效率高一点  
  其他情况，比如序号生成，这种情况下需要准确的数值，全局唯一的AtomicLong才是正确的选择  
- AtomicReference、AtomicReferenceFieldUpdater  