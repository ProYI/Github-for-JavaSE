## 继承的好处
1. 提高了代码的复用性  
2. 让类与类之间产生了关系，给第三个特征 **多态**提供了前提  

Java中支持 **单继承**，不直接支持多继承，但对C++中的多继承机制进行了改良  

## 单继承和多继承
单继承：一个子类只能有一个直接父类  
多继承：一个子类可以有多个直接父类(Java中不允许，但进行了改良)  

不直接支持，因为多个父类中有相同成员会产生调用不确定性，在Java中通过 **多实现**方式来间接支持

Java支持多层(多重)继承  
C继承B，B继承A，就会出现继承体系
C -> B -> A  

当要使用一个继承体系时
1. 查看该体系中的顶层类(类A)，了解该体系的基本功能  
2. 创建体系中的最子类对象(类C)，完成功能的使用  

## 什么时候定义继承
当类与类之间存在着所属关系时，就定义继承  
yyy是xxx中的一种 yyy extends xxx  

## 在子父类中成员的特点体现
1.  成员变量  
    当本类的成员和局部变量同名，用 **this**区分  
    当子父类中成员变量同名时，用 **super**区分  
    this和super的用法很相似  
    this：代表一个本类对象的引用  
    super：代表一个父类空间  

    子类中不可以直接访问父类的私有变量，可以通过get,set方法获得
2.  成员函数  
    当子类中出现成员函数一模一样的情况，会运行子类中的函数  
    这种现象，称为 **覆盖操作**,这是函数在子类中的特性  

    函数的 **两个特性**  
    > 重载：同一个类中  
    > 覆盖：子类中。覆盖，也称为 **重写**，**复写**

    覆盖的注意事项  
    > 子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限
    > 静态只能覆盖静态，或被静态覆盖(开发中很少出现)
3.  构造函数
    在子类构造对象时，发现访问子类构造函数时，父类也运行了，为什么？  
    原因是：在 **子类的构造函数**中，**第一行**有一个默认的隐式语句：super();  
    super(); 调用的就是父类中的空参的构造函数  

    **注**：构造函数是没有覆盖的，因为子类的构造函数不可能和父类一模一样(首先，类名就是不相同的)  

    子类的实例化过程：子类中所有的构造函数都默认会访问父类中的空参数的构造函数  

    为什么子类实例化的时候要访问父类中的构造函数呢？  
    因为子类继承了父类，互殴到了父类中的内容(属性)，所以在使用父类内容之前  
    要先看 **父类是如何对自己的内容进行初始化的**  
    所以子类在构造对象时，必须访问父类中的构造函数  
    为了完成这个必须的动作，就在子类的构造函数中加入了super()语句  

    如果 **父类中没有定义空参数构造函数**，那么子类的构造函数必须 **用super明确**要调用父类中哪个构造函数  
    同时，子类构造函数中，如果使用this调用了本类构造函数时，那么super就没有了。因为super和this都只能定义在第一行，所以只有一个，但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造函数  

    **注意**：super语句必须要定义在子类构造函数的第一行，因为父类的初始化动作要先完成  

    所有类都是Object类的子类，Object类也叫 **根类**或 **上帝类**

## 继承范例
```java
class Fu{
	Fu(){
		super();
		show();
		return;
	}
	public void show(){
		
		System.out.println("Fu show ..");
	}
}
class Zi extends Fu{
	int num = 8;
	Zi(){
		super();
		System.out.println("Zi ceshi ..."+num);
		show();
	}
	public void show(){
		System.out.println("Zi show ..."+num);
	}
}

public class ExtendsDemo {
	public static void main(String[] args){
		new Zi();
	}

}
```
### 内存图解
![OO_extends](/picture/OO/OO_extends.png)  