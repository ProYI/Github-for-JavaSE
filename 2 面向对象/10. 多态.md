# 多态
定义：某一类事物的多种存在形态  

重点：多态的多态性  
例如：猫既具备猫的形态，又具备着动物的形态  

多态在代码中的体现：父类或者接口的引用，指向其子类的对象  

## 多态的好处
提高了代码的扩展性，前期定义的代码可以使用后期的内容  
前期的代码可以调用之后出现的情况的代码  

## 多态的弊端
前期定义的内容不能使用(调用)后期子类的特有内容  

## 多态的前提（什么时候可以多态）
1. 必须要有关系。继承、实现  
2. 要有覆盖  
```java
Animal a = new Cat(); // 自动类型提升，子类对象提升了父类类型,但是特有功能无法访问
a.eat(); (父类中的eat方法)  //作用就是限制对特有功能的访问
// 专业讲：向上转型  


// 如果还想用具体动物(猫)的特有功能，可以将该对象进行向下转型  
Cat c = (Cat) a; // 向下转型的目的是为了使用子类中的特有方法。(容易造成类型转换异常)
c.eat(); (Cat类中的eat方法)  
```
**注意**：对于转型，自始自终都是 **子类对象**在做着类型的变化  

由于向下转型容易造成类型转换错误，所以要加入子类的类型判断  
```java
public static void method (Animal a) {
    a.eat();
    // instanceof:用于判断对象的具体类型，只能用于引用数据类型判断
    if(a instanceof Cat)
        向下转换成Cat类型；
    // 通常在向下转型前，用于健壮性的判断
}
```

## 多态时，成员的特点
1.  **成员变量**  
    编译时：参考 引用型变量所属的类中是否有调用的成员变量  
    有，编译通过；没有，编译失败

    运行时：参考 引用型变量所属的类中是否有调用的成员变量，并运行该所属类中的成员变量  
    简单说，编译和运行都参考等号的左边  
    ```java
    class Fu {
        int num = 3;
    }
    class Zi {
        int num = 4;
        public static void main（String[] args) {
            Fu f = new Zi();
            system.out.println(f.num);
        }
    } 
    // 开发中不常见
    ```
2.  **成员函数**(非静态)  
    编译时：参考 引用型变量所属的类中是否有调用的函数  
    有，编译通过；没有，编译失败  
    运行时：参考 对象所属的类中是否有调用的函数  
    简单说，编译看左边，运行看右边  
3.  **静态函数**  
    编译时，参考 引用型变量所属的类中是否有调用的静态方法  
    运行时，参考 引用型变量所属的类中是否有电泳的静态方法  
    简单说，编译和运行都看左边  
    其实对于静态方法，是不需要对象的，直接用类名调用即可  