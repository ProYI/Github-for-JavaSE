# 分割文件
```java
package sequenceinputstreamdemo;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class SplitFileDemo {
	private static final int SIZE = 1024*1024;

	public static void main(String[] args) throws IOException {
	    File file  = new File("晴天.mp3");
		splitFile(file);
	}

	public static void splitFile(File file) throws IOException {
		//用读取流关联源文件
		FileInputStream fis = new FileInputStream(file);
		
		//建立缓冲区
		byte[] buf = new byte[SIZE];
		
		// 创建目的
		FileOutputStream fos = null;
		
		File dir = new File("partfiles");
		if(!dir.exists())
		    dir.mkdirs();
		
		int len = 0;
		int count = 1;
		while((len = fis.read(buf)) != -1) {
			fos = new FileOutputStream(new File(dir,(count++)+".part"));
			fos.write(buf, 0, len);
		}
		fos.close();
		fis.close();
	}
}
```
# 合并文件
```java
package sequenceinputstreamdemo;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;

public class MergeFileDemo {

    private static final int SIZE = 1024*1024;

    public static void main(String[] args) throws IOException {
        File dir = new File("partfiles");
        margeFile(dir);
    }

    public static void margeFile(File dir) throws IOException {
        
        // 使用序列流合并碎片文件
        ArrayList<FileInputStream> al = new ArrayList<FileInputStream>();
        
        //获取文件夹下的碎片文件个数。每个文件都需要关联一个输入流(个人做到这的想法，有极大缺陷)
        int num = dir.listFiles().length +1;
        for(int x=1;x< num;x++) {
            al.add(new FileInputStream(new File(dir,x+".part")));
        }
        //获取枚举，使用序列流方法进行合并
        Enumeration<FileInputStream> en = Collections.enumeration(al);
        SequenceInputStream sis = new SequenceInputStream(en);
        
        //目的
        FileOutputStream fos = new FileOutputStream(new File(dir,"晴天.mp3"));
        
        byte[] buf = new byte[SIZE];
        int len = 0;
        while((len = sis.read(buf)) != -1) {
            fos.write(buf, 0, len);
        }
        fos.close();
        sis.close();
    }
}
```