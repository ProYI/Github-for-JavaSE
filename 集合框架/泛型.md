#泛型
	jdk 1.5出现的安全机制
###好处
	1.将运行时期的问题ClassCastException转到了编译时期
	2.避免了强制转换的麻烦。
	
###<>:什么时候用？
>操作的引用数据类型不确定的时候,就使用<>。将要操作的引用数据类型传入即可。
其实<>就是一个用于接收具体引用数据类型的参数范围。
	
在程序中，只要用到了带有<>的类或者接口，就要明确传入的具体引用数据类型。

###泛型方法

```
public static <Y> void method (Y obj) {
	System.out.println(-----);
}
```

当方法静态时，不能访问类上定义的泛型。如果静态方法使用泛型，只能将泛型定义在方法上。  
泛型的定义需要对象，而静态方法是没有对象的

###泛型接口  
将泛型定义在接口上  

```
interface Inter <T> { 
	public static show (T t);
}
```
###泛型的通配符  
通配符：？  未知类型

泛型的限定

```
//泛型限定只能接收 类名对象及其子类对象。上限！
public void method(Collection<? extends 类名> x) {
	----
}
```

现在看来 通配符『 ？』的功能相当于 ？extends Object

>可以对类型进行限定:  
> ？extends E:接受E类型或者E类型的子类对象。上限！  
> ? super E:接收E类型或者E的父类型。下限！


一般在存储元素的时候都是用上限，因为这样取出都是按照上限类型来运算的。不会出现类型安全隐患。

什么时候用下限呢？通常对集合中的元素进行取出操作时，可以用下限

#集合的一些技巧

>需要唯一吗？  
>需要：Set  
> > * 需要制定顺序?  
> > 需要：Tree  
> > 不需要：HashSet  
> > 但是想要一个和存储一致的顺序（有序）：LinkedHashSet

>不需要：List  
> > * 需要频繁增删吗？  
> > 需要：LinkedList  
> > 不需要：ArrayList

##如何记录每一个容器的结构和所属体系呢？  
看名字！

>List  
> - ArrayList  
> - LinkedList  

> Set  
> - HashSet  
> - TreeSet

后缀名就是该集合所属的体系。前缀名就是该集合的数据结构。

> 看到array：就要想到数组，就要想到查询快，有角标。  
> 看到link：就要想到链表，就要想到增删快，就要想到add、get、remove + frist last的方法。  
> 看到hash：就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashCode方法和equals方法。  
> 看到tree：就要想到二叉树，就要想到排序，就要想到两个接口Comparable、Comparator。  
而且通常这些常用的集合容器都是不同步的。


		

