## jdbc编程步骤：
1.	加载数据库驱动  
2.	创建并获取数据库链接  
3.	创建jdbc statement对象  
4.	设置sql语句  
5.	设置sql语句中的参数(使用preparedStatement)  
6.	通过statement执行sql并获取结果  
7.	对sql执行结果进行解析处理  
8.	释放资源(resultSet、preparedstatement、connection)  
## jdbc问题总结：
1.  数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题  
2.	Sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码  
3.	使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护  
4.	对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便  
## MyBatis介绍
MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装  
使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码  
Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来  
并通过java对象和statement中的sql进行映射生成最终执行的sql语句  
最后由mybatis框架执行sql并将结果映射成java对象并返回  
## Mybatis架构
![Mybatis架构](Mybatis架构.png)  
1.	mybatis配置
    SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息  
    mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载  
2.	通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂  
3.	由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行  
4.	mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器  
5.	Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等  
    mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id  
6.	Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo  
    Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中  
    输入参数映射就是jdbc编程中对preparedStatement设置参数  
7.	Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo  
    Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中  
    输出结果映射过程相当于jdbc编程中对结果的解析处理过程  
## Mybatis入门程序
### 第一步：需求
实现以下功能  
1.  根据用户id查询一个用户信息  
2.  根据用户名称模糊查询用户信息列表  
3.  添加用户  
4.  更新用户  
5.  删除用户  
### 第二步：加入jar包
    数据库驱动包  
    mybatis核心包  
    mybais下载文件lib下的依赖包  
### 第三步：log4j.properties
在classpath下创建log4j.properties

```
# Global logging configuration
log4j.rootLogger=DEBUG, stdout
# Console output...
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n
```
mybatis默认使用log4j作为输出日志信息  
### 第四步：SqlMapConfig.xml
在classpath下创建SqlMapConfig.xml  
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 和spring整合后 environments配置将废除-->
    <environments default="development">
        <environment id="development">
        <!-- 使用jdbc事务管理-->
            <transactionManager type="JDBC" />
        <!-- 数据库连接池-->
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver" />
                <property name="url" value="jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8" />
                <property name="username" value="root" />
                <property name="password" value="mysql" />
            </dataSource>
        </environment>
    </environments>   
</configuration>
```
SqlMapConfig.xml是mybatis核心配置文件，上边文件的配置内容为数据源、事务管理  
### 第五步：po类
Po类作为mybatis进行sql映射使用，po类通常与数据库表对应  
### 第六步：程序编写
## 查询
1.  映射文件：在classpath下的sqlmap目录下创建sql映射文件  
    Users.xml（原始ibatis命名）  
    mapper代理开发映射文件名称叫XxxMapper.xml
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <!-- namespace ：命名空间，用于隔离sql语句,对sql进行分类化管理
    注意：如果使用mapper代理方法开发，namespace有特殊的重要作用
    -->
    <mapper namespace="test">
        <!-- 在映射文件中配置很多sql语句 -->
        <!-- 通过select执行数据库查询 
            id:标识映射文件中的sql
            将sql语句封装到mappedStatement对象中，所以将id成为statement的id
            parameterType：指定输入参数的类型。这里根据实际情况指定int型
            #{}表示一个占位符号
            #{id}：其中的id表示接收输入的参数，参数名称就是id，如果输入参数是简单类型，#{}中的参数名可以任意，可以是value或其他名称
            resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象
        -->
        <select id="findUserById" parameterType="int" resultType="me.test.mybatis.po.User">
            select * from user where id=#{id}
        </select> 
        <!-- 根据用户名模糊查询用户信息，可能返回多条
        resultType:指定就是单条记录所映射的java对象类型
        ${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。
        使用${}拼接sql，引起 sql注入,存在安全隐患
        ${value}：接收输入参数的内容，如果传入类型是简单类型，${}中只能使用value
        -->
        <select id="findUserByName" parameterType="String" resultType="me.test.mybatis.po.User">
            <!-- 之前的方法也可以实现select * from user where username like #{value} -->
            select * from user where username like "%${value}%"
        </select>
    </mapper>
    ```

2.  加载映射文件  
    ```xml
    <configuration>
        <!-- 加载映射文件 -->
        <mappers>
            <mapper resource="sqlmap/User.xml"/>
        </mappers>
    </configuration>
    ```
3.  测试程序  
    ```java
    //根据id查询用户信息
    @Test
    public void findUserById() throws IOException {
        //mybatis配置文件
        String resource = "SqlMapConfig.xml";
        
        //得到配置文件流
        InputStream inputStream = Resources.getResourceAsStream(resource);
        
        //创建会话工厂，传入mybatis的配置文件信息
        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        
        //通过工厂得到SqlSession
        SqlSession sqlSession = sessionFactory.openSession();
        //通过SqlSession操作数据库
        //第一个参数：映射文件中statement的id，等于=namespace + "." + statement的id
        //第二个参数：指定和映射文件中所匹配的parameterType类型的对象
        //sqlSession.selectOne结果 是与映射文件中所匹配的resultType类型的对象
        User user = sqlSession.selectOne("test.findUserById", 1);
        
        System.out.println(user);
        
        //释放资源
        sqlSession.close();
    }

    //根据用户名称模糊查询用户列表
        @Test
        public void findUserByName() throws IOException {
            String resource = "SqlMapConfig.xml";
            InputStream inputStream = Resources.getResourceAsStream(resource);
            SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
            SqlSession sqlSession = sessionFactory.openSession();
            //List<User> list = sqlSession.selectList("test.findUserByName", "%小明%");
            List<User> list = sqlSession.selectList("test.findUserByName", "小明");
            
            for (User user : list) {
                System.out.println(user);			
            }
            
            //释放资源
            sqlSession.close();
        }
    ```
### 小结
1.  parameterType和resultType  
    parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中  
    resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象  
2.  #{}和${}  
    \#{}表示一个占位符号，通过\#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入  
    \#{}可以接收简单类型值或pojo属性值  
    如果parameterType传输单个简单类型值，\#{}括号中可以是value或其它名称  

    \${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换  
    \${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value  
3.  selectOne和selectList  
    selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常：org.apache.ibatis.exceptions.TooManyResultsException  
    selectList可以查询一条或多条记录  
## 插入
### 添加用户
```xml
    <!-- 添加用户
    parameterType:指定输入参数类型是pojo(包括用户信息)
    #{}中指定pojo的属性名，接收到pojo对象的属性值，mybatis通过ognl获取对象的属性值
    -->
    <insert id="insertUser" parameterType="me.test.mybatis.po.User">
    insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address})
    </insert>
```
```java
//添加用户
@Test
public void insertUser() throws IOException {
    String resource = "SqlMapConfig.xml";
    InputStream inputStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    SqlSession sqlSession = sessionFactory.openSession();
    //插入用户对象
    User user = new User();
    user.setUsername("张七");
    user.setBirthday(new Date());
    user.setSex("1");
    user.setAddress("陕西西安");
    sqlSession.insert("test.insertUser", user); 
    
    //提交事务
    sqlSession.commit();
    //关闭会话
    sqlSession.close();
}
```
### mysql自增主键返回
通过修改sql映射文件，可以将mysql自增主键返回  
添加selectKey实现将主键返回  
```xml
<insert id="insertUser" parameterType="me.test.mybatis.po.User">
    <!-- 将插入数据的主键返回，返回到user对象中
    select LAST_INSERT_ID()：得到刚insert进记录的主键值，只适用于自增主键
    
    keyProperty:将查询到主键值设置到parameterType指定的对象的哪个属性
    order：select LAST_INSERT_ID()的执行顺序，相对于insert语句来说的执行顺序 
    resultType:指定select LAST_INSERT_ID()的结果类型,直接写Integer也可以执行
        -->
        <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
        select LAST_INSERT_ID()
        </selectKey>
    insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address})
    </insert>
```
LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值  
### 非自增主键返回(使用uuid)
使用mysql的uuid()函数生成主键，需要修改表中id字段类型为string，长度设置成35位  
执行思路：  
先通过uuid()查询到主键，将主键输入到sql语句中  

执行uuid()语句顺序相对于insert语句之前执行  
```xml
<!-- 使用mysql的uuid生成主键
执行过程：
首先通过uuid()得到主键，将主键设置到user对象的id属性中
其次，在insert执行时，从user对象中取出id属性值
-->
<selectKey keyProperty="id" order="BEFORE" resultType="java.lang.String">
select uuid()
</selectKey>
```
### 通过oracle的序列生成主键
首先自定义一个序列且用于生成主键，selectKey使用如下  
```xml
<insert  id="insertUser" parameterType="cn.itcast.mybatis.po.User">
    <selectKey resultType="java.lang.Integer" order="BEFORE" keyProperty="id">
        SELECT 序列名.NEXTVAL() 
    </selectKey>
    insert into user(id,username,birthday,sex,address) 
	values(#{id},#{username},#{birthday},#{sex},#{address})
</insert>
```
注意这里使用的order是“BEFORE”  
## 删除和更新
```xml
<!-- 删除用户
根据id删除用户，需要输入id值
-->
<delete id="deleteUser" parameterType="java.long.Integer">
    delete from user where id=#{id}
</delete>

<!-- 根据id更新用户
分析：
需要传入用户的id
需要传入用户的更新信息
parameterType指定user对象，包括id和更新信息，注意：id必须存在
#{id}:从输入user对象中获取id属性值
-->
<update id="updateUser" parameterType="me.test.mybatis.po.User">
    update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}
    where id=#{id}
</update>
```
```java
//添加用户
...
sqlSession.delete("test.deleteUser", 28); 
...

//更新用户
...
//设置更新用户信息
User user = new User();
//必须设置id
user.setId(29);
user.setUsername("张一");
user.setBirthday(new Date());
user.setSex("2");
user.setAddress("北京北京");
sqlSession.update("test.updateUser", user);
...
```
## Mybatis解决jdbc编程的问题
1.	数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题  
    **解决**：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接  
2.	Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码  
    **解决**：将Sql语句配置在XXXXmapper.xml文件中与java代码分离  
3.	向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应  
    **解决**：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型  
4.	对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便  
    **解决**：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型  
## mybatis和hibernate本质区别和应用场景
**hibernate**  
* 是一个标准ORM框架（对象关系映射）。入门门槛较高的，不需要程序员写sql，sql语句自动生成了  
* 对sql语句进行优化、修改比较困难的  
* Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率  
但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行  

应用场景：
* 适用与需求变化不多的中小型项目，比如：后台管理系统，erp、orm、oa  

**mybatis**
* 专注是sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便  
* mybatis是一个不完全的ORM框架，虽然程序员自己写sql，mybatis 也可以实现映射（输入映射、输出映射）  
* Mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象  
* Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等  
因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大  

应用场景：
* 适用与需求变化较多的项目，比如：互联网项目  

企业进行技术选型，以低成本 高回报作为技术选型的原则，根据项目组的技术力量进行选择。  
总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好  

