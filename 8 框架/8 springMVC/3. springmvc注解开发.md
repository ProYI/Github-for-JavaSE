## 商品修改功能开发
### 需求
操作流程：  
1.  进入商品查询列表页面  
2.  点击修改，进入商品修改页面，页面中显示了要修改的商品（从数据库查询）  
	要修改的商品从数据库查询，根据商品id(主键)查询商品信息  
3.  在商品修改页面，修改商品信息，修改后，点击提交  
### 开发mapper
mapper：  
	根据id查询商品信息  
	根据id更新Items表的数据  

不用再重新开发，使用逆向工程生成的代码  
### 开发service
接口功能：  
	根据id查询商品信息  
	修改商品信息  
```java
//根据id查询商品信息
public ItemsCustom findItemsById(Integer id) throws Exception;

//修改商品信息
public void updateItems(Integer id, ItemsCustom itemsCustom) throws Exception;
```
实现类
```java
public class ItemsServiceImpl implements ItemsService{

    @Autowired
    private ItemsMapperCustom itemsMapperCustom;

    //注入逆向工程生成的mapper
    @Autowired
    private ItemsMapper itemsMapper;

    //根据id查询商品
    @Override
    public ItemsCustom findItemsById(Integer id) throws Exception {
        Items items = itemsMapper.selectByPrimaryKey(id);

        ItemsCustom itemsCustom = new ItemsCustom();
        //将items的属性值拷贝到itemsCustom
        BeanUtils.copyProperties(items, itemsCustom);
        return itemsCustom;
    }

    //更新商品信息
    @Override
    public void updateItems(Integer id, ItemsCustom itemsCustom) throws Exception {
        //添加业务校验，通常在service接口对关键参数进行校验
        //校验id是否为空。如果为空，抛出异常

        //更新商品信息使用updateByPrimaryKeyWithBLOBs根据id更新items表中所有字段，包括大文本类型字段
        //updateByPrimaryKeyWithBLOBs要求必须传入id
        itemsCustom.setId(id);
        itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom);
    }
}
```
### 开发controller
方法：  
	商品信息修改页面显示  
	商品信息修改提交  
## @RequestMapping  
特性：  
1.  url映射  
    @RequestMapping(value="/item")或@RequestMapping("/item）  
    value的值是数组，可以将多个url映射到同一个方法  
    定义controller方法对应的url，进行处理器映射使用  
2.  窄化请求映射  
     ```java
    //为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径
    //比如：商品列表：/items/queryItems.action
    @RequestMapping("/items")
    public class ItemsController {}
    ```
3.  http请求方法限定  
    限定GET方法  
    @RequestMapping(method = RequestMethod.GET)  
    如果通过Post访问则报错:HTTP Status 405 - Request method 'POST' not supported  
    例如：  
    @RequestMapping(value="/editItem",method=RequestMethod.GET)  

    限定POST方法
    @RequestMapping(method = RequestMethod.POST)  
    如果通过Post访问则报错：HTTP Status 405 - Request method 'GET' not supported  

    GET和POST都可以  
    @RequestMapping(method={RequestMethod.GET,RequestMethod.POST})  
    
    出于安全性考虑，对http的链接进行方法限制  
## controller方法的返回值
### 返回ModelAndView
需要方法结束时，定义ModelAndView，将model和view分别进行设置  
controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view  

### 返回string
如果controller方法返回string  
*   表示返回逻辑视图名  
    controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址  
    ```java
    //指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/item/editItem.jsp
    return "item/editItem";
    ```
*   真正视图(jsp路径)=前缀+逻辑视图名+后缀  
    ```java
    @RequestMapping(value="/editItems",method={RequestMethod.POST,RequestMethod.GET})
	public String editItems(Model model) Integer items_id)throws Exception {
		
		//调用service根据商品id查询商品信息
		ItemsCustom itemsCustom = itemsService.findItemsById(items_id);
		
		//通过形参中的model将model数据传到页面
		//相当于modelAndView.addObject方法
		model.addAttribute("itemsCustom", itemsCustom);
		
		return "items/editItems";
	}
	···
*   redirect重定向  
    Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中  
    ```java
    //重定向到queryItem.action地址,request无法带过去
    return "redirect:queryItem.action";
    ```
    redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response  
    由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：  
    /item/queryItem?...&…..  
*   forward页面转发  
    controller方法执行后继续执行另一个controller方法，如下商品修改提交后转向到商品修改页面，修改商品的id参数可以带到商品修改方法中  
    ```java
    //结果转发到editItem.action，request可以带过去
    return "forward:editItem.action";
    ```
    forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到  
    通过forward进行页面转发，浏览器地址栏url不变，request可以共享
### 返回void
在controller方法形参上可以定义request和response，使用request或response指定响应结果：  
1.  使用request转向页面，如下：  
    request.getRequestDispatcher("页面路径").forward(request, response);  
2.  也可以通过response页面重定向：  
    response.sendRedirect("url")  
3.  也可以通过response指定响应结果，例如响应json数据如下：  
    response.setCharacterEncoding("utf-8");  
    response.setContentType("application/json;charset=utf-8");  
    response.getWriter().write("json串");  
## 参数绑定
处理器适配器在执行Handler之前需要把http请求的key/value数据绑定到Handler方法形参数上  

注解适配器对RequestMapping标记的方法进行适配，对方法中的形参会进行参数绑定  
早期springmvc采用PropertyEditor（属性编辑器）进行参数绑定将request请求的参数绑定到方法形参上  
3.X之后springmvc就开始使用Converter进行参数绑定  
### spring参数绑定过程
从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上  

springmvc中，接收页面提交的数据是通过方法形参来接收。而不是在controller类定义成员变更接收！！！  
```
            客户端请求
            key/value

    处理器适配器调用springmvc提供参数绑定组件将key/value数据转成controller方法的形参  

    参数绑定组件：在spirngmvc早期版本使用PropertyEditor（只能将字符串传成java对象）
                后期使用converter（进行任意类型的传换）  
    spirngmvc提供了很多converter（转换器）  

    在特殊情况下需要自定义converter
    对日期数据绑定需要自定义converter

    controller方法（形参）
```
### 默认支持的类型
直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定  
*   HttpServletRequest  
    通过request对象获取请求信息  
*   HttpServletResponse  
    通过response处理响应信息  
*   HttpSession  
    通过session对象得到session中存放的对象  
*   Model/ModelMap  
    model是一个接口，modelMap是一个接口实现  
    作用：将model数据填充到request域  
    ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下：  
    ```java
    //调用service查询商品信息
    Items item = itemService.findItemById(id);
    model.addAttribute("item", item);
    ```
    页面通过${item.XXXX}获取item对象的属性值  
    使用Model和ModelMap的效果一样，如果直接使用Model，springmvc会实例化ModelMap  
### 简单类型
当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定，包括整型、字符串、单精度双精度、布尔型  
*   @RequestParam  
    通过@RequestParam对简单类型的参数进行绑定  

    如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功  
    如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致  

    通过required属性指定参数是否必须要传入，如果设置为true，但是没有传入该参数，报如下错误：  
    Http status 400-Required Integer parameter is not present  
    ```java
    //@RequestParam里边指定request传入参数名称和形参进行绑定。
	//通过required属性指定参数是否必须要传入
	//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。
	public String editItems(Model model,@RequestParam(value="id",required=true) Integer items_id)throws Exception {}
    ```
### pojo绑定
页面中input的name和controller的pojo形参中的属性名称一致，将页面中数据绑定到pojo  
```java
    //商品信息修改提交
    @RequestMapping("/editItemsSubmit")
    public String editItemsSubmit(HttpServletRequest request,Integer id,ItemsCustom itemsCustom)throws Exception {
    
    //调用service更新商品信息，页面需要将商品信息传到此方法
    itemsService.updateItems(id, itemsCustom);
    
    //页面转发
    return "forward:queryItems.action";
}
```
*   如果采用类似struts中对象.属性的方式命名，需要将pojo对象作为一个包装对象的属性，action中以该包装对象作为形参  
    包装对象定义如下：  
    ```java
    public class QueryVo {
    　　private Items items;
    }
    ```
    页面定义：  
    ```jsp
    <input type="text" name="items.name" />
    <input type="text" name="items.price" />
    ```
    Controller方法定义如下：  
    ```java
    public String useraddsubmit(Model model,QueryVo queryVo)throws Exception{
    System.out.println(queryVo.getItems());
    ```
### 自定义参数绑定实现日期类型绑定
对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定  
将请求日期数据串转成日期类型，要转换的日期类型和pojo中日期属性的类型保持一致  

所以自定义参数绑定将日期串转成java.util.Date类型  
需要向处理器适配器中注入自定义的参数绑定组件  
*   自定义日期类型绑定  
    ```java
    public class CustomDateConverter implements Converter<String,Date>{

        @Override
        public Date convert(String source) {           
            //实现 将日期串转成日期类型(格式是yyyy-MM-dd HH:mm:ss)         
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            
            try {
                //转成直接返回
                return simpleDateFormat.parse(source);
            } catch (ParseException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            //如果参数绑定失败返回null
            return null;
        }
    }
    ```
*   配置方式1(常用)  
    springmvc.xml  
    ```xml
    <!-- 自定义参数绑定 -->
	<bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
		<!-- 转换器 -->
		<property name="converters">
			<list>
				<!-- 日期类型转换 -->
				<bean class="me.test.ssmtest.controller.converter.CustomDateConverter"/>
			</list>
		</property>
	</bean>
    ```
*   配置方式2
    ```xml
    <!--注解适配器 -->
    <bean
    class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
         <property name="webBindingInitializer" ref="customBinder"></property> 
    </bean>
    
    <!-- 自定义webBinder -->
    <bean id="customBinder"
        class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer">
        <property name="conversionService" ref="conversionService" />
    </bean>
    <!-- conversionService -->
    <bean id="conversionService"
        class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
        <!-- 转换器 -->
        <property name="converters">
            <list>
                <bean class="cn.itcast.ssm.controller.converter.CustomDateConverter"/>
            </list>
        </property>
    </bean>
    ```
### 集合类
*   字符串数组  
    页面定义如下：  
    例如：页面选中多个checkbox向controller方法传递
    ```jsp
    <input type="checkbox" name="item_id" value="001"/>
    <input type="checkbox" name="item_id" value="002"/>
    <input type="checkbox" name="item_id" value="002"/>
    ```
    传递到controller方法中的格式是：001,002,003  

    Controller方法中可以用String[]接收，定义如下：
    ```java
    public String deleteitem(String[] item_id)throws Exception{
        System.out.println(item_id);
    }
    ```
*   List  
    List中存放对象，并将定义的List放在包装类中，action使用包装对象接收  
    
    页面定义如下：  
    ```jsp
    <tr>
    　　<td>
    　　　　<input type="text" name=" itemsList[0].id" value="${item.id}"/>
    　　</td>
    　　<td>
    　　　　<input type="text" name=" itemsList[0].name" value="${item.name }"/>
    　　</td>
    　　<td>
    　　　　<input type="text" name=" itemsList[0].price" value="${item.price}"/>
    　　</td>
    </tr>
    <tr>
    　　<td>
    　　　　<input type="text" name=" itemsList[1].id" value="${item.id}"/>
    　　</td>
    　　<td>
    　　　　<input type="text" name=" itemsList[1].name" value="${item.name }"/>
    　　</td>
    　　<td>
    　　　　<input type="text" name=" itemsList[1].price" value="${item.price}"/>
    　　</td>
    </tr>
    ```
    上边的静态代码改为动态jsp代码如下：  
    ```jsp
    <c:forEach items="${itemsList }" var="item" varStatus="s">
        <tr>
            <td><input type="text" name="itemsList[${s.index }].name" value="${item.name }"/></td>
            <td><input type="text" name="itemsList[${s.index }].price" value="${item.price }"/></td>
            .....
            .....
        </tr>
    </c:forEach>
    ```
    Contrller方法定义如下：  
    ```java
    public String useraddsubmit(Model model,QueryVo queryVo)throws Exception{
        System.out.println(queryVo.getItemList());
    }
    ```
*   Map对象  
    在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收  
    包装类中定义Map对象如下：  
    ```java
    public class QueryVo {
    private Map<String, Object> itemInfo = new HashMap<String, Object>();
    //get/set方法..
    }
    ```
    页面定义如下：  
    ```jsp
    <tr>
        <td>学生信息：</td>
        <td>
        姓名：<inputtype="text"name="itemInfo['name']"/>
        年龄：<inputtype="text"name="itemInfo['price']"/>
        .. .. ..
        </td>
    </tr>
    ```
    Contrller方法定义如下：  
    ```java
    public String useraddsubmit(Model model,QueryVo queryVo)throws Exception{
        System.out.println(queryVo.getStudentinfo());
    }
    ```
## springmvc和struts2的区别  
1.  springmvc基于方法开发的，struts2基于类开发的  
    springmvc将url和controller方法映射。映射成功后springmvc生成一个Handler对象，对象中只包括了一个method
    方法执行结束，形参数据销毁  
    springmvc的controller开发更类似service开发  
2.  springmvc可以进行单例开发，并且建议使用单例开发，struts2通过类的成员变量接收参数，无法使用单例，只能使用多例  
3.  经过实际测试，struts2速度慢，在于使用struts标签，如果使用struts建议使用jstl  
## 问题
*   post乱码  
    在web.xml添加post乱码filter  
    ```xml
    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>utf-8</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    ```
    以上可以解决post请求乱码问题  
*   get请求乱码  
    方法一：修改tomcat配置文件添加编码与工程编码一致，如下：  
    ```xml
    <Connector URIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/>
    ```
    方法二：对参数进行重新编码  
    ```java
    String userName;
    String(request.getParamter("userName").getBytes("ISO8859-1"),"utf-8")
    ```
    ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码  
    